import prettier from 'prettier';
import { OpenAPI2, OpenAPI2SchemaObject, PropertyMapper } from '../types/index';
import { tsUnionOf, tsArrayOf } from '../utils/index';

export const PRETTIER_OPTIONS: prettier.Options = { parser: 'typescript', singleQuote: true };

export const PRIMITIVES: { [key: string]: 'boolean' | 'string' | 'number' } = {
  // boolean types
  boolean: 'boolean',

  // string types
  binary: 'string',
  byte: 'string',
  date: 'string',
  dateTime: 'string',
  password: 'string',
  string: 'string',

  // number types
  double: 'number',
  float: 'number',
  integer: 'number',
  number: 'number',
};

export const WARNING_MESSAGE = `/**
 * This file was auto-generated by swagger-to-ts.
 * Do not make direct changes to the file.
 */
`;

// JSON handles most of the transformation for us, but it can’t handle refs, so
// they will all get converted to strings. We need a special “this is a ref”
// placeholder to distinguish it from actual strings (also, we can’t assume that
// "string" in JSON is a TypeScript type and not the actual string "string")!
const escape = (text: string) => `<@${text}@>`;
const unescape = (text: string) => text.replace(/"?<\@/g, '').replace(/\@>"?/g, ''); // replace surrounding quotes, if present

export default function generateTypesV2(schema: OpenAPI2, propertyMapper?: PropertyMapper): string {
  if (!schema.definitions) {
    throw new Error(
      `🧐 Definitions Object missing from schema https://swagger.io/specification/v2/#definitions-object`
    );
  }

  // expand $refs
  const expandedRefs = JSON.parse(JSON.stringify(schema.definitions), (_, node) =>
    node && node['$ref']
      ? escape(`definitions['${node.$ref.replace('#/definitions/', '')}']`) // important: use single-quotes here for JSON (you can always change w/ Prettier at the end)
      : node
  );

  // transform nodes
  const transformed = JSON.parse(JSON.stringify(expandedRefs), (_, node: OpenAPI2SchemaObject) => {
    // skip if node is already transformed, or not an object
    if (!node || typeof node !== 'object') {
      return node as any;
    }

    // type: enum
    if (Array.isArray(node.enum)) {
      return escape(tsUnionOf(node.enum));
    }

    // type: string / number / boolean
    const primitive = node.type && PRIMITIVES[node.type];
    if (primitive) {
      return escape(primitive);
    }

    // type: array
    if (node.type === 'array' && node.items) {
      if (typeof node.items === 'string') {
        return escape(tsArrayOf(unescape(node.items))); // if this node has already been transformed, use that
      }
      const primitive = node.items.type && PRIMITIVES[node.items.type];
      if (primitive) {
        return escape(tsArrayOf(primitive)); // if array of primitives, use that
      }
      if (!node.items.properties) {
        return escape(tsArrayOf(unescape(JSON.stringify(node.items)))); // if we’ve already transformed the items, move them up a level
      }
    }

    // type: object
    if (node.properties) {
      let properties: any = {};
      Object.entries(
        typeof node.properties === 'string' ? JSON.parse(node.properties) : node.properties
      ).forEach(([key, value]) => {
        const property = value as OpenAPI2SchemaObject;
        let optional = !node.required || !node.required.includes(key);
        let interfaceType: string | undefined;
        // let description = property.description

        // propertyMapper
        if (typeof propertyMapper === 'function') {
          const mappedResult = propertyMapper(property, {
            description: property.description,
            interfaceType: property.type as string,
            optional,
          });
          optional = mappedResult.optional;
          interfaceType = mappedResult.interfaceType;
        }

        properties[escape(`${key}${optional ? '?' : ''}`)] = interfaceType || property;
      });
      return properties;
    } else if (node.type === 'object') {
      const additionalProperties =
        typeof node.additionalProperties === 'object' && node.additionalProperties.type
          ? node.additionalProperties.type
          : 'any';
      return escape(`{ [key: string]: ${additionalProperties} }`);
    }

    // return by default
    return node;
  });

  return prettier.format(
    `${WARNING_MESSAGE}\n\n\nexport interface definitions ${unescape(JSON.stringify(transformed))}`,
    PRETTIER_OPTIONS
  );
}
